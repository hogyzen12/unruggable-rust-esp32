use ed25519_dalek::{SigningKey, Signer};
use esp_idf_svc::log::EspLogger;
use esp_idf_svc::nvs::{EspDefaultNvsPartition, EspNvs, NvsDefault};
use log::info;
use rand_core::OsRng;
use bs58;

fn load_or_generate_key(nvs: &mut EspNvs<NvsDefault>) -> anyhow::Result<SigningKey> {
    let key_name = "solana_key";
    let mut key_bytes = [0u8; 32];

    match nvs.get_raw(key_name, &mut key_bytes)? {
        Some(_) => {
            info!("Loaded existing key from NVS");
            Ok(SigningKey::from_bytes(&key_bytes))
        }
        None => {
            info!("No key found, generating new keypair...");
            let mut csprng = OsRng;
            let signing_key = SigningKey::generate(&mut csprng);
            let key_bytes = signing_key.to_bytes();
            nvs.set_raw(key_name, &key_bytes)?;
            info!("Saved new key to NVS");
            Ok(signing_key)
        }
    }
}

fn main() -> anyhow::Result<()> {
    EspLogger::initialize_default();

    let nvs_partition = EspDefaultNvsPartition::take()?;
    let mut nvs = EspNvs::new(nvs_partition, "solana_signer", true)?;

    let signing_key = load_or_generate_key(&mut nvs)?;
    let verifying_key = signing_key.verifying_key();
    let public_key_bytes = verifying_key.to_bytes();

    // Convert public key to Base58 (Solana wallet address format)
    let wallet_address = bs58::encode(public_key_bytes).into_string();
    info!("Solana Wallet Address: {}", wallet_address);
    info!("Public Key (raw): {:?}", public_key_bytes);
    info!("Private Key (raw): {:?}", signing_key.to_bytes());

    let message = b"Hello from ESP32 to Solana!";
    info!("Signing message: {:?}", message);
    let signature = signing_key.sign(message);
    info!("Signature: {:?}", signature.to_bytes());

    loop {
        std::thread::sleep(std::time::Duration::from_secs(1));
    }
}